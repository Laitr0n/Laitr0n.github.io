[{"title":"GoogleI/O2020-Go_Concurrency_Patterns","path":"/2024/06/06/GoogleI-O2020-Go-Concurrency-Patterns/","content":"内容: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491// Concurrency feature in Go// People seemed fascinated by the concurrency features of Go when the language was first announced.// Questions:// Why is concurrency supported?// Look around you. What do you see?// Do you see a single-stepping world doing one thing at a time?// Or do you see a complex world of interaction, independently behaving pieces?// That&#x27;s why. Sequential processing on its own does not model the world&#x27;s behavior.// What is concurrency, anyway?// Concurrency is the composition of independently executing computations. Concurrency is a way to structure software, particularly as a way to write clean code that interacts well with the real world.It is not parallelism.// Concurrency is not parallelism// Concurrency is not parallelism, although it enables parallelism.// If you have only one processor, your program can still be concurrent but it cannot be parallel.// On the other hand, a well-written concurrent program might run efficiently in parallel on a multiprocessor. That property could be important...// See tinyurl.com/goconcnotpar for more on that distinction. Too much to discuss here.// A model for software construction// Easy to understand.// Easy to use.// Easy to reason about.// You don&#x27;t need to be an expert!// Much nicer than dealing with the minutiae of parallelism(threads, semaphores, locks, barriers, etc.))// Distinction// Go is the latest on the Nerqueak-Alef-Limbo branch, distinguished by first channels. Erlang is closer to the original CSP, where you communicate to a process by name rather than over a channel. The models are equivalent but express things differently. Rough analogy: writing to a file by name(process, Erlang) vs. writing to a file discriptor(channel, Go).// Where does the idea come from?// What is it good for?// How do I use it?// A boring function// We need an example to show the interesting propertie of the concurrency primitives.// To avoid distraction, we make it a boring example.func boring(msg string) &#123; for i := 0; ; i++ &#123; fmt.Println(msg, i) time.Sleep(time.Second) &#125;&#125;// Slightly less boring// Make the intervals between messages unpredictables(still under a second).func boring(msg string) &#123; for i := 0; ; i++ &#123; fmt.Println(msg, i) time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond) &#125;&#125;// Running it// The boring function runs on forever, like a boring party guest.func main() &#123; boring(&quot;boring&quot;)&#125;// Ignoring it// THe go statement runs the function as usual, but doesn&#x27;t make the caller wait.It launches a goroutine. The functionality is analogous to the &amp; on the end of a shell command.// Ignoring it a littel less// Where main returns, the program exits and takes the boring function down with it. We can hang around a little, and on the way show that both main and the launched goroutine are running.func main() &#123; go boring(&quot;boring&quot;) fmt.Println(&quot;I&#x27;m listening,&quot;) time.Sleep(2 * time.Second) fmt.Println(&quot;You&#x27;re boring; I&#x27;m leaving.&quot;)&#125;// Goroutines// What is a goroutine? It&#x27;s an independently executing function, launched by a go statement.// It has its own call stack, which grows and shrinks as required.// It&#x27;s very cheap. It&#x27;s practical to have thousands, even hundreds of thousands of goroutines.// It&#x27;s not a thread.// There might be only one thread in a program with thousands of goroutines. Instead, goroutines as multiplexed dynamically onto threads as needed to keep all the goroutines running.// But if you think of it as a very cheap thread, you won&#x27;t be far off.// COmmunication// Our boring examples cheated: the main function couldn&#x27;t see the output from the other goroutine. It was just printed to the screen, where we pretended we saw a conversation. Real conversation require communication.// Channels// A channel in Go provides a connection between two goroutines, allowing them to communicate.// Declaring and initializingvar c chan intc = make(chan int)// orc := make(chan int)// Sending on a channel.c &lt;- 1// Receiving from a channel.// The &quot;arrow&quot; indicates the direction of data flow.value = &lt;- c// Using channels // A channel connects the main and boring goroutines so they can communicate.func main() &#123; c := make(chan string) go boring(&quot;boring!&quot;, c) for i := 0; i &lt; 5; i ++ &#123; fmt.Printf(&quot;You say: %q &quot;, &lt;-c) // Receive expression is just a value. &#125; fmt.Printlf(&quot;You&#x27;re boring: I&#x27;m leaving&quot;)&#125;func boring(msg string, c chan string) &#123; for i := 0; ; i++ &#123; c &lt;- fmt.Sprintf(&quot;%s %d&quot;, msg, i) // Expression to be sent can be any suitable value. time.Sleep(time.Duration(rand,Intn(1e3))* time.Millisecond) &#125;&#125;// Synchronization// When the main function executes &lt;-c, it will wait for a value to be sent.// Similarly, when the boring function executes c &lt;- value, it waits for a receiver to be ready.// A sender and receiver must both be ready to play their part in the communication. Otherwise we wait until they are.// Thus channels both communicate and synchronize.// As aside about buffered channels// Note for experts: Go channels can also be created with a buffer.// Buffering removes synchronization.// Buffering makes them more like Erlang&#x27;s mialboxes.// Buffered channels can be important for some problems but the are more subtle to reason about.// We won&#x27;t need them today.// The Go approach// Don&#x27;t communicate by sharing memory, share memory by communicating.// Generator: function that returns a channel// Channels are first-class values, just like strings or integers.c := boring(&quot;boring!&quot;) // Function returning a channel.for i := 0; i &lt; 5; i ++ &#123; fmt.Printf(&quot;You say: %q &quot;, &lt;-c)&#125;fmt.Println(&quot;You&#x27;re boring; I&#x27;m leaving&quot;)func boring(msg string) &lt;-chan string &#123; // Returns receive-only channel of strings. c := make(chan string) go func() &#123; for i := 0; ; i ++ &#123; c &lt;- fmt.Sprintlf(&quot;%s %d&quot;, msg, i) time.Sleep(time.Duration(rand,Intn(1e3))* time.Millisecond) &#125; &#125;() return c // Return the channel to caller&#125;// Channels as a handle on a service// Our boring function returns a channel that lets us communicate with the boring service it provides.// We can have more instances of the service.func main() &#123; joe := boring(&quot;Joe&quot;) ann := boring(&quot;Ann&quot;) for i := 0; i &lt; 5; i++ &#123; fmt.Println(&lt;-joe) fmt.Println(&lt;-ann) &#125; fmt.Println(&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;)&#125;// Multiplexing// These programs make Joe and Ann count in lockstep. We can instead use a fan-in function to let whosoever is ready talk.func fanIn(input1, input2 &lt;-chan string) &lt;-chan string &#123; c := make(chan string) go func() &#123;for &#123;c &lt;- &lt;-input1&#125;&#125;() go func() &#123;for &#123;c &lt;- &lt;-input2&#125;&#125;() return c&#125;func main() &#123; c := fanIn(boring(&quot;Joe&quot;), boring(&quot;Ann&quot;)) for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; fmt.Println(&quot;You&#x27;re both boring; I&#x27;m leaving. &quot;)&#125;// Restoring sequencing// Send a channel on a channel, making goroutine wait its turn.// Receive all message, then enable them again by sending on a private channel. First we define a message type that contains a channel for the reply.type Message struct &#123; str string wait chan bool&#125;// Each speaker must wait for a go-ahead.func main() &#123;\tch := fanIn(generator(&quot;Hello&quot;), generator(&quot;Bye&quot;))\tfor i := 0; i &lt; 10; i++ &#123; msg1 := &lt;-ch fmt.Println(msg1.str) msg2 := &lt;-ch fmt.Println(msg2.str) &lt;- msg1.block // reset channel, stop blocking &lt;- msg2.block\t&#125;&#125;// fanIn is itself a generatorfunc fanIn(ch1, ch2 &lt;-chan Message) &lt;-chan Message &#123; // receives two read-only channels\tnew_ch := make(chan Message)\tgo func() &#123; for &#123; new_ch &lt;- &lt;-ch1 &#125; &#125;() // launch two goroutine while loops to continuously pipe to new channel\tgo func() &#123; for &#123; new_ch &lt;- &lt;-ch2 &#125; &#125;()\treturn new_ch&#125;func generator(msg string) &lt;-chan Message &#123; // returns receive-only channel\tch := make(chan Message)\tblockingStep := make(chan int) // channel within channel to control exec, set false default\tgo func() &#123; // anonymous goroutine for i := 0; ; i++ &#123; ch &lt;- Message&#123;fmt.Sprintf(&quot;%s %d&quot;, msg, i), blockingStep&#125; time.Sleep(time.Second) blockingStep &lt;- 1 // block by waiting for input &#125;\t&#125;()\treturn ch&#125;// Select// A control structure unique to concurrency. The reason channels and goroutinex are built into the language.// The select statement provides another way to handle multiple channels. It&#x27;s like a switch, but each case is a comunication:// -All channels are evaluated.// -Selection blocks until one communication can proceed, which then does.// -If multiple can proceed, select chooses prsudo-randomly.// -A default clause, if present, executes immediately if no channel is ready.select &#123;case v1 := &lt;-c1: fmt.Printf(&quot;received %v from c1 &quot;, v1)case v2 := &lt;-c2: fmt.Printf(&quot;received %v from c2 &quot;, v2)case c3 &lt;- 23: fmt.Printf(&quot;sent %v to c3 &quot;, 23)default: fmt.Printf(&quot;no one was ready to communicate &quot;)&#125;// Fan-in again// Rewrite our original fanIn function. Only on goroutine is needed.// Old:// fanIn is itself a generatorfunc fanIn(ch1, ch2 &lt;-chan Message) &lt;-chan Message &#123; // receives two read-only channels\tnew_ch := make(chan Message)\tgo func() &#123; for &#123; new_ch &lt;- &lt;-ch1 &#125; &#125;() // launch two goroutine while loops to continuously pipe to new channel\tgo func() &#123; for &#123; new_ch &lt;- &lt;-ch2 &#125; &#125;()\treturn new_ch&#125;// New:func fanIn(ch1, ch2 &lt;-chan Message) &lt;-chan Message &#123; // receives two read-only channels new_ch := make(chan Message) go func() &#123; for &#123; select &#123; case s := &lt;- input1: c &lt;- s case s := &lt;- input2: c &lt;- s &#125; &#125; &#125;() return c&#125;// Timeout using select// The time.After function returns a channel that blicks for the specified duration. After the interval, the channel delivers the current time, onec.func main() &#123; c := boring(&quot;Joe&quot;) for &#123; select &#123; case s := &lt;- c: fmt.Println(s) case &lt;-time.After(1 * time.Second): fmt.Println(&quot;You&#x27;re too slow.&quot;) return &#125; &#125;&#125;// Timeout fro whole conversation using select// Create the timer once, outside the loop, to time out the entire conversation.(In the previous program, we had a timeout for each message.)func main() &#123; c := boring(&quot;Joe&quot;) timeout := time.After(5 * time.Second) for &#123; select &#123; case s:= &lt;-c: fmt.Println(s) case &lt;-timeout: fmt.Println(&quot;You talk too much&quot;) return &#125; &#125;&#125;// Quit channel// We can turn this around and tell Joe to stop when we&#x27;re tired of listening to hi,quit := make(chan bool)c := boring(&quot;Joe&quot;, quit)for i := rand.Intn(10); i &gt;= 0; i-- &#123;fmt.Println(&lt;-c)&#125;quit &lt;- trueselect &#123;case c &lt;- fmt.Sprintf(&quot;%s: %d&quot;, msg, i): // do nothingcase &lt;-quit: return&#125;// Receive on quit channel// How do we know it&#x27;s finished? Wati for it to tell use it&#x27;s done: receive on thq quit channelquit := make(chan string)c := boring(&quot;Joe&quot;, quit)for i := rand.Intn(10); i &gt;= 0; i-- &#123;fmt,Println(&lt;-c)&#125;quit &lt;- &quot;Bye!&quot;fmt.Printf(&quot;Joe says: %q &quot;, &lt;- quit)select &#123;case c &lt;- fmt.Sprintf(&quot;%s: %d&quot;, msg, i)// do nothingcase &lt;-quit: cleanup() quit &lt;- &quot;See you!&quot; return&#125;// Daisy-chainfunc f(left, right chan int) &#123; left &lt;- 1+ &lt;-right&#125;func main() &#123; const n = 100000 leftmost := make(chan int) right := leftmost left := leftmost for i := 0; i &lt; n; i++ &#123; right = make(chan int) go f(left, right) left = right &#125; go func(c chan int) &#123; c &lt;- 1&#125; (right) fmt.Println(&lt;-leftmost)&#125;// Systems software// Go was designed for writing systems software. Let&#x27;s see how the concurrency features come into play.// Q: What does Google search do?// A: Given a query, return a page of search results(and some ads).// Q: How do we get the search results?// A: Send the query to Web search, Image search, Youtube, Maps, etc., then mix the results.// How do we implement this?// Google Search: A fake framework// We can simulate the search function, much as we simulated conversation before.var ( Web = fakeSearch(&quot;web&quot;) Image = fakeSearch(&quot;image&quot;) Video = fakeSearch(&quot;video&quot;))type Search func(query string) Resultfunc fakeSearch(kind string) Search &#123; return func(query sting) Result &#123; time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond) return Result(fmt.Sprintf(&quot;%s result for %q &quot;, kind, query)) &#125;&#125;func main() &#123; rand.Send(time.Now().UnixNano()) start := time.Now() result := Google(&quot;golang&quot;) elapsed := time.Since(start) fmt.Println(results) fmt.Println(elapesd)&#125;// Google Search 1.0// The Google function takes a query and returns a slice of Results(which are just strings).// Google invokes Web, Image, and Video searched serially, appending them to the result slice.func Google(query string) (result []Result) &#123; results = append(results, Web(query)) results = append(results, Image(query)) results = append(results, Video(query)) return&#125;// Google Search 2.0// Run the web, Image, and Video searchs concurrently, and wait for all results. // No locks. No condition variables. No callbacks.func Google(query string) (result []Result) &#123; c := make(chan Result) go func() &#123; c &lt;- Web(query)&#125; () go func() &#123; c &lt;- Image(query)&#125; () go func() &#123; c &lt;- Video(query)&#125; () for i := 0; i &lt; 3; i ++ &#123; result := &lt;- c results = append(results, result) &#125; return&#125;// Google Search 2.1// Don&#x27;t wait for slow servers. No locks. No condition variables. No callbacks.c := make(chan Result)go func() &#123; c &lt;- Web(query)&#125; ()go func() &#123; c &lt;- Image(query)&#125; ()go func() &#123; c &lt;- Video(query)&#125; ()timeout := time.After(80 * time.Millisecond)for i := 0; i &lt; 3; i ++ &#123; select&#123; case result := &lt;- c: results = append(results, result) case &lt;- timeout: fmt.Println(&quot;time out&quot;) return &#125;&#125;return// Avoid timeout// Q: How do we avoid discarding results from slow servers?// A: Replicate the server. Send requests to multiple replicas, and use the first response.func First(query string, replicas ...Search) Result &#123; c := make(chan Result) searchReplica := func(i int) &#123; c &lt;- replicas[i](query) &#125; for i := range replicas &#123; go searchReplica(i) &#125; return &lt;-c&#125;func main() &#123; rand.Seed(time.Now().UnixNano()) start := time.Now() result := First(&quot;golang&quot;, fakeSearch(&quot;replica 1&quot;), fakeSearch(&quot;replica 2&quot;) ) elapsed := time.Since(start) fmt.Println(result) fmt.Println(elapsed)&#125;// Google Search 3.0// Reduce tail latency using replicated search servers.c := make(chan Result)go func() &#123; c &lt;- First(query, Web1, Web2)&#125; ()go func() &#123; c &lt;- First(query, Image1, Image2)&#125; ()go func() &#123; c &lt;- First(query, Video1, Video2)&#125; ()timeout := time.After(80 * time.Millisecond)for i := 0; i &lt; 3; i ++ &#123; select &#123; case result := &lt;-c: results = append(results, result) case &lt;- timeout: fmt.Println(&quot;timed out&quot;) return &#125;&#125;return// And still...// No locks. No condition variables. No callbacks.// Summary// In just a few simple transformations we used Go&#x27;s concurrency primitives to convert a // * slow// * sequential// * failure-sensitive// program into one that is // * fast// * concurent// * replicated// * robust// More party tricks// There are endless ways to use these tools, many presented elsewhere.// Chatroulette toy: tinyurl.com// Don&#x27;t overdo it// They&#x27;re fun to play with, but don&#x27;t overuse these ideas. Coroutines and channels are big ideas. They&#x27;re tools for program construction. But sometimes all you need is a reference counter. Go has &quot;sync&quot; and &quot;sync/atomic&quot; package that provide mutexes, condition variables, etc. They provide tools for smaller problems. Ofter, these things will work together to solve a bigger problem. Always use the right tool for the job.// Conclusions// Goroutines and channels make it easy to express complex operations dealing with // * multiple inputs// * multiple outputs// * timeout// * failure// And they&#x27;re fun to use."},{"title":"chmod使用","path":"/2024/03/04/chmod使用/","content":"让文件的其他用户权限为可读可写可执行chmod o&#x3D;rwx filename 增加文件的其他用户权限为可读可写可执行chmod o+rwx filename u为文件所有者,g为文件所属组,o为其他用户,a为所有用户 &#x3D;是赋予权限-是减少权限+是增加权限"},{"title":"gost使用","path":"/2024/02/29/gost使用/","content":"安装: 12# 安装最新版本 [https://github.com/go-gost/gost/releases](https://github.com/go-gost/gost/releases)bash &lt;(curl -fsSL https://github.com/go-gost/gost/raw/master/install.sh) --install Proxy Jumper service: 123456789101112[Unit]Description=GO Simple TunnelAfter=network.targetWants=network.target[Service]Type=simpleExecStart=/usr/local/bin/gost -L tcp://:38800/[Proxy Dest IP]:38800Restart=always[Install]WantedBy=multi-user.target Proxy Dest service: 123456789101112[Unit]Description=GO Simple TunnelAfter=network.targetWants=network.target[Service]Type=simpleExecStart=/usr/local/bin/gost -L=socks5+tls://:38800?notls=trueRestart=always[Install]WantedBy=multi-user.target Local Service: 1./gost -L socks://:8890 -F &#x27;socks5+tls://[Proxy Jumper IP]:38800?notls=true&#x27; -D 参考：[https://gost.run/tutorials/port-forwarding/][https://gost.run]"},{"title":"Hello World","path":"/2024/02/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]